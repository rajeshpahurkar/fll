#!/usr/bin/env pybricks-micropython
from pybricks.hubs import EV3Brick
from pybricks.ev3devices import (Motor, TouchSensor, ColorSensor,
                                 InfraredSensor, UltrasonicSensor, GyroSensor)
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile


# This program requires LEGO EV3 MicroPython v2.0 or higher.
# Click "Open user guide" on the EV3 extension tab for more information.


# Create your objects here.
ev3 = EV3Brick()


# Write your program here.
WHEEL_DIAMETER_MM=89
AXLE_TRACK_MM=135
 
 
#drive motors
left_motor=Motor(Port.B, Direction.CLOCKWISE)
right_motor=Motor(Port.C, Direction.CLOCKWISE)
robot = DriveBase(left_motor, right_motor, WHEEL_DIAMETER_MM, AXLE_TRACK_MM)

def move_straight(distance, speed_mm_s):
    duration = abs(int(1000 * distance / speed_mm_s))
    robot.drive_time(speed_mm_s, 0, duration)
#   robot.stop(stop_type=Stop.BRAKE)
#   robot.drive_time(speed_mm_s, 0, duration)
    robot.stop(stop_type=Stop.BRAKE)

# move_straight(5000, 300)
## turn(60)
move_straight(distance=150, speed_mm_s=200)
ev3.speaker.beep()

def turn_arc(distance,angle):
   robot.drive_time(distance, angle, 1000)

##move_to_color(color_sensor_left, Color.RED, 300)
color_sensor_left = ColorSensor(Port.S2)
color_sensor_right = ColorSensor(Port.S3)
def move_to_color(
    color_sensor,
    stop_on_color,
    speed_mm_s):
 
    robot.drive(speed_mm_s, 0)
    # Check if color reached.
    while color_sensor.color() != stop_on_color:
        wait(10)
    robot.stop(stop_type=Stop.BRAKE)

move_to_color(color_sensor=color_sensor_right, stop_on_color=Color.RED, speed_mm_s=300)
 
obstacle_sensor = UltrasonicSensor(Port.S4)


def turn_to_color(color_sensor, stop_on_color, angular_speed_deg_s):
   robot.drive(0, angular_speed_deg_s)
   # Check if color reached.
   while color_sensor.color() != stop_on_color:
       wait(10)
   robot.stop(stop_type=Stop.BRAKE)
    
turn_to_color(color_sensor_left, Color.RED, 45)
turn_to_color_left
def turn_to_color_right(color_sensor, stop_on_color, angular_speed_deg_s):
   robot.drive(0, angular_speed_deg_s)
   # Check if color reached.
   while color_sensor.color() != stop_on_color:
       wait(10)
   robot.stop(stop_type=Stop.BRAKE)
 
def turn_to_color_left(color_sensor, stop_on_color, angular_speed_deg_s):
   robot.drive(0, -1 * angular_speed_deg_s)
   # Check if color reached.
   while color_sensor.color() != stop_on_color:
       wait(10)
   robot.stop(stop_type=Stop.BRAKE)
WHEEL_DIAMETER_MM=89
AXLE_TRACK_MM=157
SENSOR_TO_AXLE=60
def align_with_line_to_left(color_sensor, line_color):
 
   #Find left white border of line
   move_to_color( color_sensor, line_color, 300)
   #move forward half the length of tank and rotate
   move_straight( SENSOR_TO_AXLE, 300)   
   turn_to_color_right( color_sensor, line_color, 45)
    
calibrate_gyro(0)   
# turn_to_angle( gyro, 65)
# move_straight(5000, 300)
 
crane_motor=Motor(Port.C, Direction.COUNTERCLOCKWISE, [8,24])
def move_crane_up( crane_motor, degrees):
   crane_motor.run_angle(90,  degrees, Stop.BRAKE)
 
def move_crane_down( crane_motor, degrees):
   crane_motor.run_angle(90,    -1 * degrees, Stop.BRAKE)
   def move_crane_up( crane_motor, degrees):
   crane_motor.run_angle(90,  degrees, Stop.BRAKE)
 
def move_crane_down( crane_motor, degrees):
   crane_motor.run_angle(90,    -1 * degrees, Stop.BRAKE)
   def move_crane_to_floor(crane_motor):
   crane_motor.run_until_stalled(-180, Stop.COAST, 35)
   move_crane_up( crane_motor, degrees = 5
   move_crane_to_floor(crane_motor)
  def log_string(message):
   print(message)
   brick.display.text(message)
log_string('Running robot now done')
log_string('The color on left is ' + str(color_sensor_left.color()))


SENSOR_TO_AXLE=135
# Get wheel circumference
WHEEL_CIRCUM_MM=3.149*89
# 360 degrees -> WHEEL_CIRCUM_MM so   1 degree -> ?
DEGREES_PER_MM=360/WHEEL_CIRCUM_MM
# Get wheel circumference
WHEEL_CIRCUM_MM=3.149*89
# 360 degrees -> WHEEL_CIRCUM_MM so   1 degree -> ?
DEGREES_PER_MM=360/WHEEL_CIRCUM_MM
color_test(color_sensor=color_sensor_right, distance_mm=150, speed_mm_s=50)




def move_crane_up( crane_motor, degrees):
    duration = abs(int(1000 * distance / speed_mm_s))
    # Get wheel circumference
WHEEL_CIRCUM_MM=3.149*89
# 360 degrees -> WHEEL_CIRCUM_MM so   1 degree -> ?
DEGREES_PER_MM=360/WHEEL_CIRCUM_MM

motor_target_angle = int(DEGREES_PER_MM * distance_mm)
   left_motor.reset_angle(0)

      while (abs(left_motor.angle()) < abs(motor_target_angle)):
         error = target_angle - gyro.angle()
                 robot.drive(speed_mm_s, error)
